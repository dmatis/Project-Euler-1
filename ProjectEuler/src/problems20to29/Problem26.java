package problems20to29;

import java.math.BigInteger;
import personal_library.MathFunctions;

//Question -----------------------------------------------------------------------------------------------------------------------
//	A unit fraction contains 1 in the numerator. The decimal representation of the unit fractions with denominators 2 to 10 are given:
//	
//	1/2	= 	0.5
//	1/3	= 	0.(3)
//	1/4	= 	0.25
//	1/5	= 	0.2
//	1/6	= 	0.1(6)
//	1/7	= 	0.(142857)
//	1/8	= 	0.125
//	1/9	= 	0.(1)
//	1/10	= 	0.1
//	Where 0.1(6) means 0.166666..., and has a 1-digit recurring cycle. It can be seen that 1/7 has a 6-digit recurring cycle.
//	
//	Find the value of d < 1000 for which 1/d contains the longest recurring cycle in its decimal fraction part.
//---------- -----------------------------------------------------------------------------------------------------------------------
// Solution correct 


// General Idea: A recurring cycle x long can be represented as (one-sequence-of-recurrence / nines-recurrence-long)
// Eg. 0.11111 = 1 / 9
//     0.121212 = 12 / 99
//
// So the idea is to take the fraction (eg. 1 / 7) and see how many 9s you need before nines-recurrence-long % denominator == 0
// that way you get the length of the recurrence! So for the example:
//   999999 % 7 == 0 and that's how you get --> ( 1 / 7 ) = ( 142857 / 999999 )
//
// There are two things to be weary of with this method:
//	 	1. You must make sure that the fraction does indeed have a recurrence to begin with
//      2. You must be careful with situations like 1/6 where the recurrence does not start immediately (0.1666666)
//
// Problem 1:
// 		As I go through the denominator and attempt to put it over a series of 9s I also attempt to see if 10^n % denominator == 0
//		If I find some n where 10^n % denominator == 0 then this number has no recurrence. 
//			eg. 1 / 4 has no recurrence (0.25) and can be seen with this technique as 100 % 4 == 0 
//
// Problem 2: 
//		This is a more difficult problem to deal with, and one must think about how a situation arises where the recurrence does not
//		begin at the start but rather after some x digits. For example, 1 / 6 has a recurrence 1-long but it starts at the second digit (0.16666)
// 		After some thought, you realize that 1 / 6 = (1 / 3) * (1 / 2) and that the recurrence is generated by the (1 / 3) and that the (1 / 2)
// 		simply shifts the recurrence resulting in it starting at the second digit. This means that any denominator that is not a prime that has a 
//  	recurrence can be written as the prime that caused the recurrence * non-primes. Hence, the only denominators that we must look at are
//		prime! This makes the search must faster as well as getting rid of situations where the recurrence does not begin at the first digit!
public class Problem26 {

	private static int answer; 
	private static int index; 
	private static boolean notFound;
	private static int currentGreatestLength; 
 
	public static void main(String[] args) {
		currentGreatestLength = 0; 
		for(index = 1; index < 1000; index++) {
			if(MathFunctions.checkPrime(index)) {
				notFound = true; 
				int a = 0; 
				while(notFound) {	
					checkOverNines(a);
					checkOverTens(a);
				    a++;
				}
			}
		}
		// Print out the answer
        System.out.println(answer);
	}

	// Private Function
	// 
	private static void checkOverTens(int a) {
		BigInteger biggieSmalls = BigInteger.TEN;
		for(int b = 0; b < a; b++) {
			biggieSmalls = biggieSmalls.multiply(BigInteger.TEN);
		}
		if(biggieSmalls.remainder(BigInteger.valueOf(index)).equals(BigInteger.ZERO)) {
			notFound = false; 
		}	
	}

	// Private Function
	// 
	private static void checkOverNines(int a) {
		String nines = "9";
		for(int i = 0; i < a;i++) {
			nines = nines.concat("9");
		}
		BigInteger ninesNumber = new BigInteger(nines);
		if(ninesNumber.remainder(BigInteger.valueOf(index)).equals(BigInteger.ZERO)) {
			if(nines.length() > currentGreatestLength) {
				answer = index; 
				currentGreatestLength = nines.length();
			}
			notFound = false; 
		}		
	}
}